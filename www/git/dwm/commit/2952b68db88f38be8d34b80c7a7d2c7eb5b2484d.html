<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>cleanup - dwm - dynamic window manager
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="dwm Atom Feed" href="../atom.xml" />
<link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="/logo.png" alt="" width="32" height="32" /></a></td><td><h1>dwm</h1><span class="desc">dynamic window manager
</span></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/2952b68db88f38be8d34b80c7a7d2c7eb5b2484d.html">2952b68db88f38be8d34b80c7a7d2c7eb5b2484d</a>
<b>parent</b> <a href="../commit/bb3bd6fec37174e8d4bb9457ca815c00609e5157.html">bb3bd6fec37174e8d4bb9457ca815c00609e5157</a>
<b>Author:</b> Markus Teich &lt;<a href="mailto:markus.teich@stusta.mhn.de">markus.teich@stusta.mhn.de</a>&gt;
<b>Date:</b>   Sat,  7 Jan 2017 17:21:28 +0100

cleanup

- unify multi-line expression alignment style.
- unify multi-line function call alignment style.
- simplify client moving on monitor count decrease.
- clarify comment for focusin().
- remove old confusing comment about input focus fix in focusmon(). The
  explanation is already in the old commit message, so no need to keep it in the
  code.
- remove old comment describing even older state of the code in focus().
- unify comment style.
- break up some long lines.
- fix some typos and grammar.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">LICENSE</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">config.def.h</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">dwm.c</a></td><td> | </td><td class="num">64</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d">----------------------------------</span></td></tr>
</table></pre><pre>3 files changed, 32 insertions(+), 36 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/LICENSE.html">LICENSE</a> b/<a href="../file/LICENSE.html">LICENSE</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -16,7 +16,7 @@ MIT/X Consortium License
</a> © 2011 Christoph Lohmann &lt;20h@r-36.net&gt;
 © 2015-2016 Quentin Rameau &lt;quinq@fifth.space&gt;
 © 2015-2016 Eric Pruitt &lt;eric.pruitt@gmail.com&gt;
<a href="#h0-0-3" id="h0-0-3" class="d">-© 2016 Markus Teich &lt;markus.teich@stusta.mhn.de&gt;
</a><a href="#h0-0-4" id="h0-0-4" class="i">+© 2016-2017 Markus Teich &lt;markus.teich@stusta.mhn.de&gt;
</a> 
 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the &quot;Software&quot;),
<b>diff --git a/<a id="h1" href="../file/config.def.h.html">config.def.h</a> b/<a href="../file/config.def.h.html">config.def.h</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -15,7 +15,7 @@ static const char col_cyan[]        = &quot;#005577&quot;;
</a> static const char *colors[][3]      = {
 	/*               fg         bg         border   */
 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
<a href="#h1-0-3" id="h1-0-3" class="d">-	[SchemeSel] =  { col_gray4, col_cyan,  col_cyan  },
</a><a href="#h1-0-4" id="h1-0-4" class="i">+	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
</a> };
 
 /* tagging */
<b>diff --git a/<a id="h2" href="../file/dwm.c.html">dwm.c</a> b/<a href="../file/dwm.c.html">dwm.c</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -3,7 +3,7 @@
</a>  * dynamic window manager is designed like any other X client as well. It is
  * driven through handling X events. In contrast to other X clients, a window
  * manager selects for SubstructureRedirectMask on the root window, to receive
<a href="#h2-0-3" id="h2-0-3" class="d">- * events about window (dis-)appearance.  Only one X connection at a time is
</a><a href="#h2-0-4" id="h2-0-4" class="i">+ * events about window (dis-)appearance. Only one X connection at a time is
</a>  * allowed to select for this event mask.
  *
  * The event handlers of dwm are organized in an array which is accessed
<a href="#h2-1" id="h2-1" class="h">@@ -11,7 +11,7 @@
</a>  * in O(1) time.
  *
  * Each child of the root window is called a client, except windows which have
<a href="#h2-1-3" id="h2-1-3" class="d">- * set the override_redirect flag.  Clients are organized in a linked client
</a><a href="#h2-1-4" id="h2-1-4" class="i">+ * set the override_redirect flag. Clients are organized in a linked client
</a>  * list on each monitor, the focus history is remembered through a stack list
  * on each monitor. Each client contains a bit array to indicate the tags of a
  * client.
<a href="#h2-2" id="h2-2" class="h">@@ -517,7 +517,8 @@ clientmessage(XEvent *e)
</a> 	if (!c)
 		return;
 	if (cme-&gt;message_type == netatom[NetWMState]) {
<a href="#h2-2-3" id="h2-2-3" class="d">-		if (cme-&gt;data.l[1] == netatom[NetWMFullscreen] || cme-&gt;data.l[2] == netatom[NetWMFullscreen])
</a><a href="#h2-2-4" id="h2-2-4" class="i">+		if (cme-&gt;data.l[1] == netatom[NetWMFullscreen]
</a><a href="#h2-2-5" id="h2-2-5" class="i">+		|| cme-&gt;data.l[2] == netatom[NetWMFullscreen])
</a> 			setfullscreen(c, (cme-&gt;data.l[0] == 1 /* _NET_WM_STATE_ADD    */
 			              || (cme-&gt;data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ &amp;&amp; !c-&gt;isfullscreen)));
 	} else if (cme-&gt;message_type == netatom[NetActiveWindow]) {
<a href="#h2-3" id="h2-3" class="h">@@ -783,7 +784,6 @@ focus(Client *c)
</a> {
 	if (!c || !ISVISIBLE(c))
 		for (c = selmon-&gt;stack; c &amp;&amp; !ISVISIBLE(c); c = c-&gt;snext);
<a href="#h2-3-3" id="h2-3-3" class="d">-	/* was if (selmon-&gt;sel) */
</a> 	if (selmon-&gt;sel &amp;&amp; selmon-&gt;sel != c)
 		unfocus(selmon-&gt;sel, 0);
 	if (c) {
<a href="#h2-4" id="h2-4" class="h">@@ -804,7 +804,7 @@ focus(Client *c)
</a> 	drawbars();
 }
 
<a href="#h2-4-3" id="h2-4-3" class="d">-/* there are some broken focus acquiring clients */
</a><a href="#h2-4-4" id="h2-4-4" class="i">+/* there are some broken focus acquiring clients needing extra handling */
</a> void
 focusin(XEvent *e)
 {
<a href="#h2-5" id="h2-5" class="h">@@ -823,8 +823,7 @@ focusmon(const Arg *arg)
</a> 		return;
 	if ((m = dirtomon(arg-&gt;i)) == selmon)
 		return;
<a href="#h2-5-3" id="h2-5-3" class="d">-	unfocus(selmon-&gt;sel, 0); /* s/1/0/ fixes input focus issues
</a><a href="#h2-5-4" id="h2-5-4" class="d">-					in gedit and anjuta */
</a><a href="#h2-5-5" id="h2-5-5" class="i">+	unfocus(selmon-&gt;sel, 0);
</a> 	selmon = m;
 	focus(NULL);
 }
<a href="#h2-6" id="h2-6" class="h">@@ -961,7 +960,7 @@ grabkeys(void)
</a> 			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
 				for (j = 0; j &lt; LENGTH(modifiers); j++)
 					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
<a href="#h2-6-3" id="h2-6-3" class="d">-						 True, GrabModeAsync, GrabModeAsync);
</a><a href="#h2-6-4" id="h2-6-4" class="i">+					         True, GrabModeAsync, GrabModeAsync);
</a> 	}
 }
 
<a href="#h2-7" id="h2-7" class="h">@@ -1151,7 +1150,7 @@ movemouse(const Arg *arg)
</a> 	ocx = c-&gt;x;
 	ocy = c-&gt;y;
 	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
<a href="#h2-7-3" id="h2-7-3" class="d">-	None, cursor[CurMove]-&gt;cursor, CurrentTime) != GrabSuccess)
</a><a href="#h2-7-4" id="h2-7-4" class="i">+	    None, cursor[CurMove]-&gt;cursor, CurrentTime) != GrabSuccess)
</a> 		return;
 	if (!getrootptr(&amp;x, &amp;y))
 		return;
<a href="#h2-8" id="h2-8" class="h">@@ -1434,7 +1433,7 @@ setclientstate(Client *c, long state)
</a> 	long data[] = { state, None };
 
 	XChangeProperty(dpy, c-&gt;win, wmatom[WMState], wmatom[WMState], 32,
<a href="#h2-8-3" id="h2-8-3" class="d">-			PropModeReplace, (unsigned char *)data, 2);
</a><a href="#h2-8-4" id="h2-8-4" class="i">+	                PropModeReplace, (unsigned char *)data, 2);
</a> }
 
 int
<a href="#h2-9" id="h2-9" class="h">@@ -1516,7 +1515,7 @@ setlayout(const Arg *arg)
</a> 		drawbar(selmon);
 }
 
<a href="#h2-9-3" id="h2-9-3" class="d">-/* arg &gt; 1.0 will set mfact absolutly */
</a><a href="#h2-9-4" id="h2-9-4" class="i">+/* arg &gt; 1.0 will set mfact absolutely */
</a> void
 setmfact(const Arg *arg)
 {
<a href="#h2-10" id="h2-10" class="h">@@ -1581,19 +1580,20 @@ setup(void)
</a> 	/* supporting window for NetWMCheck */
 	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
<a href="#h2-10-3" id="h2-10-3" class="d">-		PropModeReplace, (unsigned char *) &amp;wmcheckwin, 1);
</a><a href="#h2-10-4" id="h2-10-4" class="i">+	                PropModeReplace, (unsigned char *) &amp;wmcheckwin, 1);
</a> 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
<a href="#h2-10-6" id="h2-10-6" class="d">-		PropModeReplace, (unsigned char *) &quot;dwm&quot;, 4);
</a><a href="#h2-10-7" id="h2-10-7" class="i">+	                PropModeReplace, (unsigned char *) &quot;dwm&quot;, 4);
</a> 	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
<a href="#h2-10-9" id="h2-10-9" class="d">-		PropModeReplace, (unsigned char *) &amp;wmcheckwin, 1);
</a><a href="#h2-10-10" id="h2-10-10" class="i">+	                PropModeReplace, (unsigned char *) &amp;wmcheckwin, 1);
</a> 	/* EWMH support per view */
 	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
<a href="#h2-10-13" id="h2-10-13" class="d">-			PropModeReplace, (unsigned char *) netatom, NetLast);
</a><a href="#h2-10-14" id="h2-10-14" class="i">+	                PropModeReplace, (unsigned char *) netatom, NetLast);
</a> 	XDeleteProperty(dpy, root, netatom[NetClientList]);
<a href="#h2-10-16" id="h2-10-16" class="d">-	/* select for events */
</a><a href="#h2-10-17" id="h2-10-17" class="i">+	/* select events */
</a> 	wa.cursor = cursor[CurNormal]-&gt;cursor;
<a href="#h2-10-19" id="h2-10-19" class="d">-	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask|ButtonPressMask|PointerMotionMask
</a><a href="#h2-10-20" id="h2-10-20" class="d">-	                |EnterWindowMask|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
</a><a href="#h2-10-21" id="h2-10-21" class="i">+	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
</a><a href="#h2-10-22" id="h2-10-22" class="i">+	                |ButtonPressMask|PointerMotionMask|EnterWindowMask
</a><a href="#h2-10-23" id="h2-10-23" class="i">+	                |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
</a> 	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &amp;wa);
 	XSelectInput(dpy, root, wa.event_mask);
 	grabkeys();
<a href="#h2-11" id="h2-11" class="h">@@ -1769,12 +1769,11 @@ unmanage(Client *c, int destroyed)
</a> 	Monitor *m = c-&gt;mon;
 	XWindowChanges wc;
 
<a href="#h2-11-3" id="h2-11-3" class="d">-	/* The server grab construct avoids race conditions. */
</a> 	detach(c);
 	detachstack(c);
 	if (!destroyed) {
 		wc.border_width = c-&gt;oldbw;
<a href="#h2-11-8" id="h2-11-8" class="d">-		XGrabServer(dpy);
</a><a href="#h2-11-9" id="h2-11-9" class="i">+		XGrabServer(dpy); /* avoid race conditions */
</a> 		XSetErrorHandler(xerrordummy);
 		XConfigureWindow(dpy, c-&gt;win, CWBorderWidth, &amp;wc); /* restore border */
 		XUngrabButton(dpy, AnyButton, AnyModifier, c-&gt;win);
<a href="#h2-12" id="h2-12" class="h">@@ -1871,8 +1870,8 @@ updategeom(void)
</a> 				memcpy(&amp;unique[j++], &amp;info[i], sizeof(XineramaScreenInfo));
 		XFree(info);
 		nn = j;
<a href="#h2-12-3" id="h2-12-3" class="d">-		if (n &lt;= nn) {
</a><a href="#h2-12-4" id="h2-12-4" class="d">-			for (i = 0; i &lt; (nn - n); i++) { /* new monitors available */
</a><a href="#h2-12-5" id="h2-12-5" class="i">+		if (n &lt;= nn) { /* new monitors available */
</a><a href="#h2-12-6" id="h2-12-6" class="i">+			for (i = 0; i &lt; (nn - n); i++) {
</a> 				for (m = mons; m &amp;&amp; m-&gt;next; m = m-&gt;next);
 				if (m)
 					m-&gt;next = createmon();
<a href="#h2-13" id="h2-13" class="h">@@ -1881,8 +1880,8 @@ updategeom(void)
</a> 			}
 			for (i = 0, m = mons; i &lt; nn &amp;&amp; m; m = m-&gt;next, i++)
 				if (i &gt;= n
<a href="#h2-13-3" id="h2-13-3" class="d">-				|| (unique[i].x_org != m-&gt;mx || unique[i].y_org != m-&gt;my
</a><a href="#h2-13-4" id="h2-13-4" class="d">-				    || unique[i].width != m-&gt;mw || unique[i].height != m-&gt;mh))
</a><a href="#h2-13-5" id="h2-13-5" class="i">+				|| unique[i].x_org != m-&gt;mx || unique[i].y_org != m-&gt;my
</a><a href="#h2-13-6" id="h2-13-6" class="i">+				|| unique[i].width != m-&gt;mw || unique[i].height != m-&gt;mh)
</a> 				{
 					dirty = 1;
 					m-&gt;num = i;
<a href="#h2-14" id="h2-14" class="h">@@ -1892,13 +1891,11 @@ updategeom(void)
</a> 					m-&gt;mh = m-&gt;wh = unique[i].height;
 					updatebarpos(m);
 				}
<a href="#h2-14-3" id="h2-14-3" class="d">-		} else {
</a><a href="#h2-14-4" id="h2-14-4" class="d">-			/* less monitors available nn &lt; n */
</a><a href="#h2-14-5" id="h2-14-5" class="i">+		} else { /* less monitors available nn &lt; n */
</a> 			for (i = nn; i &lt; n; i++) {
 				for (m = mons; m &amp;&amp; m-&gt;next; m = m-&gt;next);
<a href="#h2-14-8" id="h2-14-8" class="d">-				while (m-&gt;clients) {
</a><a href="#h2-14-9" id="h2-14-9" class="i">+				while ((c = m-&gt;clients)) {
</a> 					dirty = 1;
<a href="#h2-14-11" id="h2-14-11" class="d">-					c = m-&gt;clients;
</a> 					m-&gt;clients = c-&gt;next;
 					detachstack(c);
 					c-&gt;mon = mons;
<a href="#h2-15" id="h2-15" class="h">@@ -1913,8 +1910,7 @@ updategeom(void)
</a> 		free(unique);
 	} else
 #endif /* XINERAMA */
<a href="#h2-15-3" id="h2-15-3" class="d">-	/* default monitor setup */
</a><a href="#h2-15-4" id="h2-15-4" class="d">-	{
</a><a href="#h2-15-5" id="h2-15-5" class="i">+	{ /* default monitor setup */
</a> 		if (!mons)
 			mons = createmon();
 		if (mons-&gt;mw != sw || mons-&gt;mh != sh) {
<a href="#h2-16" id="h2-16" class="h">@@ -1988,7 +1984,7 @@ updatesizehints(Client *c)
</a> 	} else
 		c-&gt;maxa = c-&gt;mina = 0.0;
 	c-&gt;isfixed = (c-&gt;maxw &amp;&amp; c-&gt;minw &amp;&amp; c-&gt;maxh &amp;&amp; c-&gt;minh
<a href="#h2-16-3" id="h2-16-3" class="d">-	             &amp;&amp; c-&gt;maxw == c-&gt;minw &amp;&amp; c-&gt;maxh == c-&gt;minh);
</a><a href="#h2-16-4" id="h2-16-4" class="i">+	              &amp;&amp; c-&gt;maxw == c-&gt;minw &amp;&amp; c-&gt;maxh == c-&gt;minh);
</a> }
 
 void
<a href="#h2-17" id="h2-17" class="h">@@ -2082,8 +2078,8 @@ wintomon(Window w)
</a> }
 
 /* There&#39;s no way to check accesses to destroyed windows, thus those cases are
<a href="#h2-17-3" id="h2-17-3" class="d">- * ignored (especially on UnmapNotify&#39;s).  Other types of errors call Xlibs
</a><a href="#h2-17-4" id="h2-17-4" class="d">- * default error handler, which may call exit.  */
</a><a href="#h2-17-5" id="h2-17-5" class="i">+ * ignored (especially on UnmapNotify&#39;s). Other types of errors call Xlibs
</a><a href="#h2-17-6" id="h2-17-6" class="i">+ * default error handler, which may call exit. */
</a> int
 xerror(Display *dpy, XErrorEvent *ee)
 {
<a href="#h2-18" id="h2-18" class="h">@@ -2098,7 +2094,7 @@ xerror(Display *dpy, XErrorEvent *ee)
</a> 	|| (ee-&gt;request_code == X_CopyArea &amp;&amp; ee-&gt;error_code == BadDrawable))
 		return 0;
 	fprintf(stderr, &quot;dwm: fatal error: request code=%d, error code=%d\n&quot;,
<a href="#h2-18-3" id="h2-18-3" class="d">-			ee-&gt;request_code, ee-&gt;error_code);
</a><a href="#h2-18-4" id="h2-18-4" class="i">+	        ee-&gt;request_code, ee-&gt;error_code);
</a> 	return xerrorxlib(dpy, ee); /* may call exit */
 }
 
</pre>
</div>
</body>
</html>
