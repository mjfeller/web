<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Cancel DCS with SUB, CAN, ESC or any CC1 code - st-light - Unnamed repository; edit this file &#39;description&#39; to name the repository.
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="st-light Atom Feed" href="../atom.xml" />
<link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="/logo.png" alt="" width="32" height="32" /></a></td><td><h1>st-light</h1><span class="desc">Unnamed repository; edit this file &#39;description&#39; to name the repository.
</span></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/aa35bbd7a16c6c210a7574a8c45bbe939d5b2922.html">aa35bbd7a16c6c210a7574a8c45bbe939d5b2922</a>
<b>parent</b> <a href="../commit/704d12442e85ded011f71c95e90534ebacc81692.html">704d12442e85ded011f71c95e90534ebacc81692</a>
<b>Author:</b> Roberto E. Vargas Caballero &lt;<a href="mailto:k0ga@shike2.com">k0ga@shike2.com</a>&gt;
<b>Date:</b>   Sat, 26 Apr 2014 01:34:46 +0200

Cancel DCS with SUB, CAN, ESC or any CC1 code

From http://www.vt100.net/docs/vt510-rm/chapter4:

	*The VT510 ignores all following characters until it receives a
	 SUB, ST, or any other C1 control character.

So OSC, PM and APC sequence ends with a SUB (it cancels the sequence
and show a question mark as error), ST or any another C1 (8 bits)
code, or their C0 (7 bits) equivalent sequences (at this moment we
do not handle C1 codes, but we should). But it is also said that:

	Cancel  CAN
	1/8     Immediately cancels an escape sequence, control sequence,
		or device control string in progress. In this case, the
		VT510 does not display any error character.

	Escape  ESC
	1/11    Introduces an escape sequence. ESC also cancels any escape
		sequence, control sequence, or device control string in
		progress.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">st.c</a></td><td> | </td><td class="num">206</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------</span></td></tr>
</table></pre><pre>1 file changed, 127 insertions(+), 79 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/st.c.html">st.c</a> b/<a href="../file/st.c.html">st.c</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -70,6 +70,8 @@ char *argv0;
</a> #define LEN(a)     (sizeof(a) / sizeof(a)[0])
 #define DEFAULT(a, b)     (a) = (a) ? (a) : (b)
 #define BETWEEN(x, a, b)  ((a) &lt;= (x) &amp;&amp; (x) &lt;= (b))
<a href="#h0-0-3" id="h0-0-3" class="i">+#define ISCONTROLC0(c) (BETWEEN((uchar) (c), 0, 0x1f))
</a><a href="#h0-0-4" id="h0-0-4" class="i">+#define ISCONTROLC1(c) (BETWEEN((uchar) (c), 0x80, 0x9f))
</a> #define LIMIT(x, a, b)    (x) = (x) &lt; (a) ? (a) : (x) &gt; (b) ? (b) : (x)
 #define ATTRCMP(a, b) ((a).mode != (b).mode || (a).fg != (b).fg || (a).bg != (b).bg)
 #define IS_SET(flag) ((term.mode &amp; (flag)) != 0)
<a href="#h0-1" id="h0-1" class="h">@@ -390,6 +392,7 @@ static void tsetdirtattr(int);
</a> static void tsetmode(bool, bool, int *, int);
 static void tfulldirt(void);
 static void techo(char *, int);
<a href="#h0-1-3" id="h0-1-3" class="i">+static bool tcontrolcode(uchar );
</a> static int32_t tdefcolor(int *, int *, int);
 static void tselcs(void);
 static void tdeftran(char);
<a href="#h0-2" id="h0-2" class="h">@@ -399,6 +402,7 @@ static void ttyread(void);
</a> static void ttyresize(void);
 static void ttysend(char *, size_t);
 static void ttywrite(const char *, size_t);
<a href="#h0-2-3" id="h0-2-3" class="i">+static inline bool iscontrol(char);
</a> 
 static void xdraws(char *, Glyph, int, int, int, int);
 static void xhints(void);
<a href="#h0-3" id="h0-3" class="h">@@ -2136,6 +2140,7 @@ strhandle(void) {
</a> 	char *p = NULL;
 	int j, narg, par;
 
<a href="#h0-3-3" id="h0-3-3" class="i">+	term.esc &amp;= ~(ESC_STR_END|ESC_STR);
</a> 	strparse();
 	narg = strescseq.narg;
 	par = atoi(strescseq.args[0]);
<a href="#h0-4" id="h0-4" class="h">@@ -2295,13 +2300,22 @@ tputtab(int n) {
</a> 	tmoveto(x, term.c.y);
 }
 
<a href="#h0-4-3" id="h0-4-3" class="i">+static inline bool
</a><a href="#h0-4-4" id="h0-4-4" class="i">+iscontrol(char c) {
</a><a href="#h0-4-5" id="h0-4-5" class="i">+	return ISCONTROLC0(c) || ISCONTROLC1(c);
</a><a href="#h0-4-6" id="h0-4-6" class="i">+}
</a><a href="#h0-4-7" id="h0-4-7" class="i">+
</a> void
 techo(char *buf, int len) {
 	for(; len &gt; 0; buf++, len--) {
 		char c = *buf;
 
<a href="#h0-4-13" id="h0-4-13" class="d">-		if(BETWEEN(c, 0x00, 0x1f) || c == 0x7f) { /* control code */
</a><a href="#h0-4-14" id="h0-4-14" class="d">-			if(c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39; &amp;&amp; c != &#39;\t&#39;) {
</a><a href="#h0-4-15" id="h0-4-15" class="i">+		if(iscontrol(c)) { /* control code */
</a><a href="#h0-4-16" id="h0-4-16" class="i">+			if(c &amp; 0x80) {
</a><a href="#h0-4-17" id="h0-4-17" class="i">+				c &amp;= 0x7f;
</a><a href="#h0-4-18" id="h0-4-18" class="i">+				tputc(&quot;^&quot;, 1);
</a><a href="#h0-4-19" id="h0-4-19" class="i">+				tputc(&quot;[&quot;, 1);
</a><a href="#h0-4-20" id="h0-4-20" class="i">+			} else if(c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39; &amp;&amp; c != &#39;\t&#39;) {
</a> 				c ^= &#39;\x40&#39;;
 				tputc(&quot;^&quot;, 1);
 			}
<a href="#h0-5" id="h0-5" class="h">@@ -2340,58 +2354,135 @@ tselcs(void) {
</a> 	       ATTR_GFX);
 }
 
<a href="#h0-5-3" id="h0-5-3" class="i">+bool
</a><a href="#h0-5-4" id="h0-5-4" class="i">+tcontrolcode(uchar ascii) {
</a><a href="#h0-5-5" id="h0-5-5" class="i">+	static char question[UTF_SIZ] = &quot;?&quot;;
</a><a href="#h0-5-6" id="h0-5-6" class="i">+
</a><a href="#h0-5-7" id="h0-5-7" class="i">+	switch(ascii) {
</a><a href="#h0-5-8" id="h0-5-8" class="i">+	case &#39;\t&#39;:   /* HT */
</a><a href="#h0-5-9" id="h0-5-9" class="i">+		tputtab(1);
</a><a href="#h0-5-10" id="h0-5-10" class="i">+		break;
</a><a href="#h0-5-11" id="h0-5-11" class="i">+	case &#39;\b&#39;:   /* BS */
</a><a href="#h0-5-12" id="h0-5-12" class="i">+		tmoveto(term.c.x-1, term.c.y);
</a><a href="#h0-5-13" id="h0-5-13" class="i">+		break;
</a><a href="#h0-5-14" id="h0-5-14" class="i">+	case &#39;\r&#39;:   /* CR */
</a><a href="#h0-5-15" id="h0-5-15" class="i">+		tmoveto(0, term.c.y);
</a><a href="#h0-5-16" id="h0-5-16" class="i">+		break;
</a><a href="#h0-5-17" id="h0-5-17" class="i">+	case &#39;\f&#39;:   /* LF */
</a><a href="#h0-5-18" id="h0-5-18" class="i">+	case &#39;\v&#39;:   /* VT */
</a><a href="#h0-5-19" id="h0-5-19" class="i">+	case &#39;\n&#39;:   /* LF */
</a><a href="#h0-5-20" id="h0-5-20" class="i">+		/* go to first col if the mode is set */
</a><a href="#h0-5-21" id="h0-5-21" class="i">+		tnewline(IS_SET(MODE_CRLF));
</a><a href="#h0-5-22" id="h0-5-22" class="i">+		break;
</a><a href="#h0-5-23" id="h0-5-23" class="i">+	case &#39;\a&#39;:   /* BEL */
</a><a href="#h0-5-24" id="h0-5-24" class="i">+		if(term.esc &amp; ESC_STR_END) {
</a><a href="#h0-5-25" id="h0-5-25" class="i">+			/* backwards compatibility to xterm */
</a><a href="#h0-5-26" id="h0-5-26" class="i">+			strhandle();
</a><a href="#h0-5-27" id="h0-5-27" class="i">+		} else {
</a><a href="#h0-5-28" id="h0-5-28" class="i">+			if(!(xw.state &amp; WIN_FOCUSED))
</a><a href="#h0-5-29" id="h0-5-29" class="i">+				xseturgency(1);
</a><a href="#h0-5-30" id="h0-5-30" class="i">+			if (bellvolume)
</a><a href="#h0-5-31" id="h0-5-31" class="i">+				XBell(xw.dpy, bellvolume);
</a><a href="#h0-5-32" id="h0-5-32" class="i">+		}
</a><a href="#h0-5-33" id="h0-5-33" class="i">+		break;
</a><a href="#h0-5-34" id="h0-5-34" class="i">+	case &#39;\033&#39;: /* ESC */
</a><a href="#h0-5-35" id="h0-5-35" class="i">+		csireset();
</a><a href="#h0-5-36" id="h0-5-36" class="i">+		term.esc &amp;= ~(ESC_CSI|ESC_ALTCHARSET|ESC_TEST);
</a><a href="#h0-5-37" id="h0-5-37" class="i">+		term.esc |= ESC_START;
</a><a href="#h0-5-38" id="h0-5-38" class="i">+		return 1;
</a><a href="#h0-5-39" id="h0-5-39" class="i">+	case &#39;\016&#39;: /* SO */
</a><a href="#h0-5-40" id="h0-5-40" class="i">+		term.charset = 0;
</a><a href="#h0-5-41" id="h0-5-41" class="i">+		tselcs();
</a><a href="#h0-5-42" id="h0-5-42" class="i">+		break;
</a><a href="#h0-5-43" id="h0-5-43" class="i">+	case &#39;\017&#39;: /* SI */
</a><a href="#h0-5-44" id="h0-5-44" class="i">+		term.charset = 1;
</a><a href="#h0-5-45" id="h0-5-45" class="i">+		tselcs();
</a><a href="#h0-5-46" id="h0-5-46" class="i">+		break;
</a><a href="#h0-5-47" id="h0-5-47" class="i">+	case &#39;\032&#39;: /* SUB */
</a><a href="#h0-5-48" id="h0-5-48" class="i">+		tsetchar(question, &amp;term.c.attr, term.c.x, term.c.y);
</a><a href="#h0-5-49" id="h0-5-49" class="i">+	case &#39;\030&#39;: /* CAN */
</a><a href="#h0-5-50" id="h0-5-50" class="i">+		csireset();
</a><a href="#h0-5-51" id="h0-5-51" class="i">+		break;
</a><a href="#h0-5-52" id="h0-5-52" class="i">+	case &#39;\005&#39;: /* ENQ (IGNORED) */
</a><a href="#h0-5-53" id="h0-5-53" class="i">+	case &#39;\000&#39;: /* NUL (IGNORED) */
</a><a href="#h0-5-54" id="h0-5-54" class="i">+	case &#39;\021&#39;: /* XON (IGNORED) */
</a><a href="#h0-5-55" id="h0-5-55" class="i">+	case &#39;\023&#39;: /* XOFF (IGNORED) */
</a><a href="#h0-5-56" id="h0-5-56" class="i">+	case 0177:   /* DEL (IGNORED) */
</a><a href="#h0-5-57" id="h0-5-57" class="i">+	case 0x84:   /* TODO: IND */
</a><a href="#h0-5-58" id="h0-5-58" class="i">+	case 0x85:   /* TODO: NEL */
</a><a href="#h0-5-59" id="h0-5-59" class="i">+	case 0x88:   /* TODO: HTS */
</a><a href="#h0-5-60" id="h0-5-60" class="i">+	case 0x8d:   /* TODO: RI */
</a><a href="#h0-5-61" id="h0-5-61" class="i">+	case 0x8e:   /* TODO: SS2 */
</a><a href="#h0-5-62" id="h0-5-62" class="i">+	case 0x8f:   /* TODO: SS3 */
</a><a href="#h0-5-63" id="h0-5-63" class="i">+	case 0x90:   /* TODO: DCS */
</a><a href="#h0-5-64" id="h0-5-64" class="i">+	case 0x98:   /* TODO: SOS */
</a><a href="#h0-5-65" id="h0-5-65" class="i">+	case 0x9a:   /* TODO: DECID */
</a><a href="#h0-5-66" id="h0-5-66" class="i">+	case 0x9b:   /* TODO: CSI */
</a><a href="#h0-5-67" id="h0-5-67" class="i">+	case 0x9c:   /* TODO: ST */
</a><a href="#h0-5-68" id="h0-5-68" class="i">+	case 0x9d:   /* TODO: OSC */
</a><a href="#h0-5-69" id="h0-5-69" class="i">+	case 0x9e:   /* TODO: PM */
</a><a href="#h0-5-70" id="h0-5-70" class="i">+	case 0x9f:   /* TODO: APC */
</a><a href="#h0-5-71" id="h0-5-71" class="i">+		break;
</a><a href="#h0-5-72" id="h0-5-72" class="i">+	default:
</a><a href="#h0-5-73" id="h0-5-73" class="i">+		return 0;
</a><a href="#h0-5-74" id="h0-5-74" class="i">+	}
</a><a href="#h0-5-75" id="h0-5-75" class="i">+	term.esc &amp;= ~(ESC_STR_END|ESC_STR);
</a><a href="#h0-5-76" id="h0-5-76" class="i">+	return 1;
</a><a href="#h0-5-77" id="h0-5-77" class="i">+}
</a><a href="#h0-5-78" id="h0-5-78" class="i">+
</a> void
 tputc(char *c, int len) {
<a href="#h0-5-81" id="h0-5-81" class="d">-	uchar ascii = *c;
</a><a href="#h0-5-82" id="h0-5-82" class="d">-	bool control = ascii &lt; &#39;\x20&#39; || ascii == 0177;
</a><a href="#h0-5-83" id="h0-5-83" class="i">+	uchar ascii;
</a><a href="#h0-5-84" id="h0-5-84" class="i">+	bool control;
</a> 	long unicodep;
 	int width;
 
 	if(len == 1) {
 		width = 1;
<a href="#h0-5-90" id="h0-5-90" class="i">+		ascii = *c;
</a> 	} else {
 		utf8decode(c, &amp;unicodep, UTF_SIZ);
 		width = wcwidth(unicodep);
<a href="#h0-5-94" id="h0-5-94" class="i">+		ascii = unicodep;
</a> 	}
 
<a href="#h0-5-97" id="h0-5-97" class="i">+	control = iscontrol(ascii) &amp;&amp; width == 1;
</a> 	if(IS_SET(MODE_PRINT))
 		tprinter(c, len);
 
 	/*
<a href="#h0-5-102" id="h0-5-102" class="d">-	 * STR sequences must be checked before anything else
</a><a href="#h0-5-103" id="h0-5-103" class="d">-	 * because it can use some control codes as part of the sequence.
</a><a href="#h0-5-104" id="h0-5-104" class="i">+	 * STR sequence must be checked before anything else
</a><a href="#h0-5-105" id="h0-5-105" class="i">+	 * because it uses all following characters until it
</a><a href="#h0-5-106" id="h0-5-106" class="i">+	 * receives a ESC, a SUB, a ST or any other C1 control
</a><a href="#h0-5-107" id="h0-5-107" class="i">+	 * character.
</a> 	 */
 	if(term.esc &amp; ESC_STR) {
<a href="#h0-5-110" id="h0-5-110" class="d">-		switch(ascii) {
</a><a href="#h0-5-111" id="h0-5-111" class="d">-		case &#39;\033&#39;:
</a><a href="#h0-5-112" id="h0-5-112" class="d">-			term.esc = ESC_START | ESC_STR_END;
</a><a href="#h0-5-113" id="h0-5-113" class="d">-			break;
</a><a href="#h0-5-114" id="h0-5-114" class="d">-		case &#39;\a&#39;: /* backwards compatibility to xterm */
</a><a href="#h0-5-115" id="h0-5-115" class="d">-			term.esc = 0;
</a><a href="#h0-5-116" id="h0-5-116" class="d">-			strhandle();
</a><a href="#h0-5-117" id="h0-5-117" class="d">-			break;
</a><a href="#h0-5-118" id="h0-5-118" class="d">-		default:
</a><a href="#h0-5-119" id="h0-5-119" class="d">-			if(strescseq.len + len &lt; sizeof(strescseq.buf) - 1) {
</a><a href="#h0-5-120" id="h0-5-120" class="d">-				memmove(&amp;strescseq.buf[strescseq.len], c, len);
</a><a href="#h0-5-121" id="h0-5-121" class="d">-				strescseq.len += len;
</a><a href="#h0-5-122" id="h0-5-122" class="d">-			} else {
</a><a href="#h0-5-123" id="h0-5-123" class="d">-			/*
</a><a href="#h0-5-124" id="h0-5-124" class="d">-			 * Here is a bug in terminals. If the user never sends
</a><a href="#h0-5-125" id="h0-5-125" class="d">-			 * some code to stop the str or esc command, then st
</a><a href="#h0-5-126" id="h0-5-126" class="d">-			 * will stop responding. But this is better than
</a><a href="#h0-5-127" id="h0-5-127" class="d">-			 * silently failing with unknown characters. At least
</a><a href="#h0-5-128" id="h0-5-128" class="d">-			 * then users will report back.
</a><a href="#h0-5-129" id="h0-5-129" class="d">-			 *
</a><a href="#h0-5-130" id="h0-5-130" class="d">-			 * In the case users ever get fixed, here is the code:
</a><a href="#h0-5-131" id="h0-5-131" class="d">-			 */
</a><a href="#h0-5-132" id="h0-5-132" class="d">-			/*
</a><a href="#h0-5-133" id="h0-5-133" class="d">-			 * term.esc = 0;
</a><a href="#h0-5-134" id="h0-5-134" class="d">-			 * strhandle();
</a><a href="#h0-5-135" id="h0-5-135" class="d">-			 */
</a><a href="#h0-5-136" id="h0-5-136" class="d">-			}
</a><a href="#h0-5-137" id="h0-5-137" class="d">-			break;
</a><a href="#h0-5-138" id="h0-5-138" class="i">+		if(width == 1 &amp;&amp;
</a><a href="#h0-5-139" id="h0-5-139" class="i">+		   (ascii == &#39;\a&#39; || ascii == 030 ||
</a><a href="#h0-5-140" id="h0-5-140" class="i">+		    ascii == 032  || ascii == 033 ||
</a><a href="#h0-5-141" id="h0-5-141" class="i">+		    ISCONTROLC1(ascii))) {
</a><a href="#h0-5-142" id="h0-5-142" class="i">+			term.esc &amp;= ~ESC_STR;
</a><a href="#h0-5-143" id="h0-5-143" class="i">+			term.esc |= ESC_STR_END;
</a><a href="#h0-5-144" id="h0-5-144" class="i">+		} else if(strescseq.len + len &lt; sizeof(strescseq.buf) - 1) {
</a><a href="#h0-5-145" id="h0-5-145" class="i">+			memmove(&amp;strescseq.buf[strescseq.len], c, len);
</a><a href="#h0-5-146" id="h0-5-146" class="i">+			strescseq.len += len;
</a><a href="#h0-5-147" id="h0-5-147" class="i">+			return;
</a><a href="#h0-5-148" id="h0-5-148" class="i">+		} else {
</a><a href="#h0-5-149" id="h0-5-149" class="i">+		/*
</a><a href="#h0-5-150" id="h0-5-150" class="i">+		 * Here is a bug in terminals. If the user never sends
</a><a href="#h0-5-151" id="h0-5-151" class="i">+		 * some code to stop the str or esc command, then st
</a><a href="#h0-5-152" id="h0-5-152" class="i">+		 * will stop responding. But this is better than
</a><a href="#h0-5-153" id="h0-5-153" class="i">+		 * silently failing with unknown characters. At least
</a><a href="#h0-5-154" id="h0-5-154" class="i">+		 * then users will report back.
</a><a href="#h0-5-155" id="h0-5-155" class="i">+		 *
</a><a href="#h0-5-156" id="h0-5-156" class="i">+		 * In the case users ever get fixed, here is the code:
</a><a href="#h0-5-157" id="h0-5-157" class="i">+		 */
</a><a href="#h0-5-158" id="h0-5-158" class="i">+		/*
</a><a href="#h0-5-159" id="h0-5-159" class="i">+		 * term.esc = 0;
</a><a href="#h0-5-160" id="h0-5-160" class="i">+		 * strhandle();
</a><a href="#h0-5-161" id="h0-5-161" class="i">+		 */
</a><a href="#h0-5-162" id="h0-5-162" class="i">+			return;
</a> 		}
<a href="#h0-5-164" id="h0-5-164" class="d">-		return;
</a> 	}
 
 	/*
<a href="#h0-6" id="h0-6" class="h">@@ -2400,51 +2491,8 @@ tputc(char *c, int len) {
</a> 	 * they must not cause conflicts with sequences.
 	 */
 	if(control) {
<a href="#h0-6-3" id="h0-6-3" class="d">-		switch(ascii) {
</a><a href="#h0-6-4" id="h0-6-4" class="d">-		case &#39;\t&#39;:   /* HT */
</a><a href="#h0-6-5" id="h0-6-5" class="d">-			tputtab(1);
</a><a href="#h0-6-6" id="h0-6-6" class="i">+		if (tcontrolcode(ascii))
</a> 			return;
<a href="#h0-6-8" id="h0-6-8" class="d">-		case &#39;\b&#39;:   /* BS */
</a><a href="#h0-6-9" id="h0-6-9" class="d">-			tmoveto(term.c.x-1, term.c.y);
</a><a href="#h0-6-10" id="h0-6-10" class="d">-			return;
</a><a href="#h0-6-11" id="h0-6-11" class="d">-		case &#39;\r&#39;:   /* CR */
</a><a href="#h0-6-12" id="h0-6-12" class="d">-			tmoveto(0, term.c.y);
</a><a href="#h0-6-13" id="h0-6-13" class="d">-			return;
</a><a href="#h0-6-14" id="h0-6-14" class="d">-		case &#39;\f&#39;:   /* LF */
</a><a href="#h0-6-15" id="h0-6-15" class="d">-		case &#39;\v&#39;:   /* VT */
</a><a href="#h0-6-16" id="h0-6-16" class="d">-		case &#39;\n&#39;:   /* LF */
</a><a href="#h0-6-17" id="h0-6-17" class="d">-			/* go to first col if the mode is set */
</a><a href="#h0-6-18" id="h0-6-18" class="d">-			tnewline(IS_SET(MODE_CRLF));
</a><a href="#h0-6-19" id="h0-6-19" class="d">-			return;
</a><a href="#h0-6-20" id="h0-6-20" class="d">-		case &#39;\a&#39;:   /* BEL */
</a><a href="#h0-6-21" id="h0-6-21" class="d">-			if(!(xw.state &amp; WIN_FOCUSED))
</a><a href="#h0-6-22" id="h0-6-22" class="d">-				xseturgency(1);
</a><a href="#h0-6-23" id="h0-6-23" class="d">-			if (bellvolume)
</a><a href="#h0-6-24" id="h0-6-24" class="d">-				XBell(xw.dpy, bellvolume);
</a><a href="#h0-6-25" id="h0-6-25" class="d">-			return;
</a><a href="#h0-6-26" id="h0-6-26" class="d">-		case &#39;\033&#39;: /* ESC */
</a><a href="#h0-6-27" id="h0-6-27" class="d">-			csireset();
</a><a href="#h0-6-28" id="h0-6-28" class="d">-			term.esc = ESC_START;
</a><a href="#h0-6-29" id="h0-6-29" class="d">-			return;
</a><a href="#h0-6-30" id="h0-6-30" class="d">-		case &#39;\016&#39;: /* SO */
</a><a href="#h0-6-31" id="h0-6-31" class="d">-			term.charset = 0;
</a><a href="#h0-6-32" id="h0-6-32" class="d">-			tselcs();
</a><a href="#h0-6-33" id="h0-6-33" class="d">-			return;
</a><a href="#h0-6-34" id="h0-6-34" class="d">-		case &#39;\017&#39;: /* SI */
</a><a href="#h0-6-35" id="h0-6-35" class="d">-			term.charset = 1;
</a><a href="#h0-6-36" id="h0-6-36" class="d">-			tselcs();
</a><a href="#h0-6-37" id="h0-6-37" class="d">-			return;
</a><a href="#h0-6-38" id="h0-6-38" class="d">-		case &#39;\032&#39;: /* SUB */
</a><a href="#h0-6-39" id="h0-6-39" class="d">-		case &#39;\030&#39;: /* CAN */
</a><a href="#h0-6-40" id="h0-6-40" class="d">-			csireset();
</a><a href="#h0-6-41" id="h0-6-41" class="d">-			return;
</a><a href="#h0-6-42" id="h0-6-42" class="d">-		case &#39;\005&#39;: /* ENQ (IGNORED) */
</a><a href="#h0-6-43" id="h0-6-43" class="d">-		case &#39;\000&#39;: /* NUL (IGNORED) */
</a><a href="#h0-6-44" id="h0-6-44" class="d">-		case &#39;\021&#39;: /* XON (IGNORED) */
</a><a href="#h0-6-45" id="h0-6-45" class="d">-		case &#39;\023&#39;: /* XOFF (IGNORED) */
</a><a href="#h0-6-46" id="h0-6-46" class="d">-		case 0177:   /* DEL (IGNORED) */
</a><a href="#h0-6-47" id="h0-6-47" class="d">-			return;
</a><a href="#h0-6-48" id="h0-6-48" class="d">-		}
</a> 	} else if(term.esc &amp; ESC_START) {
 		if(term.esc &amp; ESC_CSI) {
 			csiescseq.buf[csiescseq.len++] = ascii;
</pre>
</div>
</body>
</html>
