<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>base64dec: don&#39;t read out of bounds - st - simple terminal
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="st Atom Feed" href="../atom.xml" />
<link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="/logo.png" alt="" width="32" height="32" /></a></td><td><h1>st</h1><span class="desc">simple terminal
</span></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/ea4d933ed9d8ce16699c84892a29e070c70b2eb9.html">ea4d933ed9d8ce16699c84892a29e070c70b2eb9</a>
<b>parent</b> <a href="../commit/83866428de031300eab03fbb116bcf7d2b1d4f60.html">83866428de031300eab03fbb116bcf7d2b1d4f60</a>
<b>Author:</b> Avi Halachmi (:avih) &lt;<a href="mailto:avihpit@yahoo.com">avihpit@yahoo.com</a>&gt;
<b>Date:</b>   Wed, 16 Oct 2019 11:17:23 +0300

base64dec: don&#39;t read out of bounds

Previously, base64dec checked terminating input &#39;\0&#39; every 4 calls to
base64dec_getc, where the latter progressed one or more chars on each
call, and could read past &#39;\0&#39; in the way it was used.

The input to base64dec currently comes only from OSC 52 escape seq
(copy to clipboard), and reading past &#39;\0&#39; or even past the buffer
boundary was easy to trigger.

Also, even if we could trust external input to be valid base64, there
are different base64 standards, and not all of them require padding
to 4 bytes blocks (using trailing &#39;=&#39; chars).

It didn&#39;t affect short OSC 52 strings because the buffer is initialized
to 0&#39;s, so typically it did stop within the buffer, but if the string
was trimmed to fit (the buffer is 512 bytes) then it did also read past
the end of the buffer, and the decoded suffix ended up arbitrary.

This patch makes base64dec_getc not progress past &#39;\0&#39;, and instead
produce fake trailing padding of &#39;=&#39;.

Additionally, at base64dec, if padding is detected at the first or
second byte of a quartet, then we identify it as invalid and abort
(a valid quartet has at least two leading non-padding bytes).

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">st.c</a></td><td> | </td><td class="num">6</td><td><span class="i">+++++</span><span class="d">-</span></td></tr>
</table></pre><pre>1 file changed, 5 insertions(+), 1 deletion(-)
<hr/><b>diff --git a/<a id="h0" href="../file/st.c.html">st.c</a> b/<a href="../file/st.c.html">st.c</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -366,7 +366,7 @@ char
</a> base64dec_getc(const char **src)
 {
 	while (**src &amp;&amp; !isprint(**src)) (*src)++;
<a href="#h0-0-3" id="h0-0-3" class="d">-	return *((*src)++);
</a><a href="#h0-0-4" id="h0-0-4" class="i">+	return **src ? *((*src)++) : &#39;=&#39;;  /* emulate padding if string ends */
</a> }
 
 char *
<a href="#h0-1" id="h0-1" class="h">@@ -384,6 +384,10 @@ base64dec(const char *src)
</a> 		int c = base64_digits[(unsigned char) base64dec_getc(&amp;src)];
 		int d = base64_digits[(unsigned char) base64dec_getc(&amp;src)];
 
<a href="#h0-1-3" id="h0-1-3" class="i">+		/* invalid input. &#39;a&#39; can be -1, e.g. if src is &quot;\n&quot; (c-str) */
</a><a href="#h0-1-4" id="h0-1-4" class="i">+		if (a == -1 || b == -1)
</a><a href="#h0-1-5" id="h0-1-5" class="i">+			break;
</a><a href="#h0-1-6" id="h0-1-6" class="i">+
</a> 		*dst++ = (a &lt;&lt; 2) | ((b &amp; 0x30) &gt;&gt; 4);
 		if (c == -1)
 			break;
</pre>
</div>
</body>
</html>
