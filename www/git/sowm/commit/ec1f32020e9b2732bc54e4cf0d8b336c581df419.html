<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>sowm: removed comments for now. Will be added back in a better format. - sowm - Unnamed repository; edit this file &#39;description&#39; to name the repository.
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="sowm Atom Feed" href="../atom.xml" />
<link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="/logo.png" alt="" width="32" height="32" /></a></td><td><h1>sowm</h1><span class="desc">Unnamed repository; edit this file &#39;description&#39; to name the repository.
</span></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/ec1f32020e9b2732bc54e4cf0d8b336c581df419.html">ec1f32020e9b2732bc54e4cf0d8b336c581df419</a>
<b>parent</b> <a href="../commit/f098fde9cd435d8395f3fa560880ffc3a439554d.html">f098fde9cd435d8395f3fa560880ffc3a439554d</a>
<b>Author:</b> Dylan Araps &lt;<a href="mailto:dylan.araps@gmail.com">dylan.araps@gmail.com</a>&gt;
<b>Date:</b>   Thu, 17 Oct 2019 15:44:49 +0300

sowm: removed comments for now. Will be added back in a better format.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">sowm.c</a></td><td> | </td><td class="num">225</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
</table></pre><pre>1 file changed, 0 insertions(+), 225 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/sowm.c.html">sowm.c</a> b/<a href="../file/sowm.c.html">sowm.c</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -61,10 +61,6 @@ static Display           *d;
</a> static Window            root, cur;
 static XButtonEvent      mouse;
 
<a href="#h0-0-3" id="h0-0-3" class="d">-/*
</a><a href="#h0-0-4" id="h0-0-4" class="d">-   The list of events to subscribe to and the paired functions
</a><a href="#h0-0-5" id="h0-0-5" class="d">-   to call on an event.
</a><a href="#h0-0-6" id="h0-0-6" class="d">-*/
</a> static void (*events[LASTEvent])(XEvent *e) = {
     [ButtonPress]      = button_press,
     [ButtonRelease]    = button_release,
<a href="#h0-1" id="h0-1" class="h">@@ -78,106 +74,31 @@ static void (*events[LASTEvent])(XEvent *e) = {
</a> 
 #include &quot;config.h&quot;
 
<a href="#h0-1-3" id="h0-1-3" class="d">-/*
</a><a href="#h0-1-4" id="h0-1-4" class="d">-   Iterate over the current desktop&#39;s client list.
</a><a href="#h0-1-5" id="h0-1-5" class="d">-*/
</a> #define win (client *c=list;c;c=c-&gt;next)
 
<a href="#h0-1-8" id="h0-1-8" class="d">-/*
</a><a href="#h0-1-9" id="h0-1-9" class="d">-   Focus the given window.
</a><a href="#h0-1-10" id="h0-1-10" class="d">-*/
</a> #define win_focus(W) XSetInputFocus(d, W, RevertToParent, CurrentTime);
 
<a href="#h0-1-13" id="h0-1-13" class="d">-/*
</a><a href="#h0-1-14" id="h0-1-14" class="d">-   This function stores the desired window&#39;s geometry.
</a><a href="#h0-1-15" id="h0-1-15" class="d">-
</a><a href="#h0-1-16" id="h0-1-16" class="d">-   This previously used &#39;XGetWindowAttributes&#39; which
</a><a href="#h0-1-17" id="h0-1-17" class="d">-   returned too much information. We only need x, y, w, h and
</a><a href="#h0-1-18" id="h0-1-18" class="d">-   not a list of 20 or so attributes of differing types.
</a><a href="#h0-1-19" id="h0-1-19" class="d">-
</a><a href="#h0-1-20" id="h0-1-20" class="d">-   &#39;XGetWindowAttributes&#39; also calls &#39;XGetGeometry&#39; to return
</a><a href="#h0-1-21" id="h0-1-21" class="d">-   this information, so lets just call it directly and skip
</a><a href="#h0-1-22" id="h0-1-22" class="d">-   the middleman.
</a><a href="#h0-1-23" id="h0-1-23" class="d">-*/
</a> #define win_size(W, gx, gy, gw, gh) \
     XGetGeometry(d, W, &amp;(Window){0}, gx, gy, gw, gh, \
                  &amp;(unsigned int){0}, &amp;(unsigned int){0});
 
<a href="#h0-1-28" id="h0-1-28" class="d">-/*
</a><a href="#h0-1-29" id="h0-1-29" class="d">-   &#39;sowm&#39; doesn&#39;t keep track of the currently focused window
</a><a href="#h0-1-30" id="h0-1-30" class="d">-   and instead grabs the window under the cursor when needed.
</a><a href="#h0-1-31" id="h0-1-31" class="d">-
</a><a href="#h0-1-32" id="h0-1-32" class="d">-   This is a super lazy way of handling current focus, however
</a><a href="#h0-1-33" id="h0-1-33" class="d">-   it aligns perfectly with mouse-follows-focus.
</a><a href="#h0-1-34" id="h0-1-34" class="d">-
</a><a href="#h0-1-35" id="h0-1-35" class="d">-   Logic elsewhere will select a real window if this function
</a><a href="#h0-1-36" id="h0-1-36" class="d">-   returns the &#39;root&#39; window.
</a><a href="#h0-1-37" id="h0-1-37" class="d">-
</a><a href="#h0-1-38" id="h0-1-38" class="d">-   This function returns the current window while at the same
</a><a href="#h0-1-39" id="h0-1-39" class="d">-   time defining a global variable to contain its value. This
</a><a href="#h0-1-40" id="h0-1-40" class="d">-   allows for stupidily simple usage.
</a><a href="#h0-1-41" id="h0-1-41" class="d">-
</a><a href="#h0-1-42" id="h0-1-42" class="d">-   Example: if (win_current() != root) XKillClient(d, cur);
</a><a href="#h0-1-43" id="h0-1-43" class="d">-
</a><a href="#h0-1-44" id="h0-1-44" class="d">-   The value can be used as function output and then
</a><a href="#h0-1-45" id="h0-1-45" class="d">-   the same value can be used as a variable directly afterwards.
</a><a href="#h0-1-46" id="h0-1-46" class="d">-*/
</a> Window win_current() {
     XGetInputFocus(d, &amp;cur, (int[]){1});
     return cur;
 }
 
<a href="#h0-1-52" id="h0-1-52" class="d">-/*
</a><a href="#h0-1-53" id="h0-1-53" class="d">-   When a window is destroyed it is first removed from the
</a><a href="#h0-1-54" id="h0-1-54" class="d">-   current desktop&#39;s window list and finally focus is shifted.
</a><a href="#h0-1-55" id="h0-1-55" class="d">-
</a><a href="#h0-1-56" id="h0-1-56" class="d">-   Focus goes to the window under the cursor if it is *not*
</a><a href="#h0-1-57" id="h0-1-57" class="d">-   the root window. If it is the root window, focus goes to
</a><a href="#h0-1-58" id="h0-1-58" class="d">-   the first window in the desktop.
</a><a href="#h0-1-59" id="h0-1-59" class="d">-*/
</a> void notify_destroy(XEvent *e) {
     win_del(e-&gt;xdestroywindow.window);
 
     if (list) win_focus(win_current() == root ? list-&gt;w : cur);
 }
 
<a href="#h0-1-66" id="h0-1-66" class="d">-/*
</a><a href="#h0-1-67" id="h0-1-67" class="d">-   When the mouse enters or leaves a window this function
</a><a href="#h0-1-68" id="h0-1-68" class="d">-   handles which window shall be focused next.
</a><a href="#h0-1-69" id="h0-1-69" class="d">-
</a><a href="#h0-1-70" id="h0-1-70" class="d">-   The while loop firstly compresses all &#39;EnterNotify&#39;
</a><a href="#h0-1-71" id="h0-1-71" class="d">-   events down to only the latest which is an optimization
</a><a href="#h0-1-72" id="h0-1-72" class="d">-   when focus changes very quickly (e.g a desktop focus).
</a><a href="#h0-1-73" id="h0-1-73" class="d">-
</a><a href="#h0-1-74" id="h0-1-74" class="d">-   There&#39;s no use in computing each and every event as we
</a><a href="#h0-1-75" id="h0-1-75" class="d">-   only really care about the newest one.
</a><a href="#h0-1-76" id="h0-1-76" class="d">-
</a><a href="#h0-1-77" id="h0-1-77" class="d">-   Focus is only then changed if the mouse has entered a
</a><a href="#h0-1-78" id="h0-1-78" class="d">-   window which is *not* the root window.
</a><a href="#h0-1-79" id="h0-1-79" class="d">-*/
</a> void notify_enter(XEvent *e) {
     while(XCheckTypedEvent(d, EnterNotify, e));
 
     win_focus(e-&gt;xcrossing.window)
 }
 
<a href="#h0-1-86" id="h0-1-86" class="d">-/*
</a><a href="#h0-1-87" id="h0-1-87" class="d">-   When the mouse is moved and the paired modifier is
</a><a href="#h0-1-88" id="h0-1-88" class="d">-   pressed this function handles a window move or a window
</a><a href="#h0-1-89" id="h0-1-89" class="d">-   resize.
</a><a href="#h0-1-90" id="h0-1-90" class="d">-
</a><a href="#h0-1-91" id="h0-1-91" class="d">-   &#39;mouse&#39; is defined on a modifier+mouse press and then
</a><a href="#h0-1-92" id="h0-1-92" class="d">-   discarded on a modifier+mouse release.
</a><a href="#h0-1-93" id="h0-1-93" class="d">-
</a><a href="#h0-1-94" id="h0-1-94" class="d">-   The while loop firstly compresses all &#39;MotionNotify&#39;
</a><a href="#h0-1-95" id="h0-1-95" class="d">-   events down to only the latest which is an optimization
</a><a href="#h0-1-96" id="h0-1-96" class="d">-   when motion happens very quickly.
</a><a href="#h0-1-97" id="h0-1-97" class="d">-
</a><a href="#h0-1-98" id="h0-1-98" class="d">-   There&#39;s no use in computing each and every event as we
</a><a href="#h0-1-99" id="h0-1-99" class="d">-   only really care about the newest one.
</a><a href="#h0-1-100" id="h0-1-100" class="d">-
</a><a href="#h0-1-101" id="h0-1-101" class="d">-   The window is then moved or resized.
</a><a href="#h0-1-102" id="h0-1-102" class="d">-*/
</a> void notify_motion(XEvent *e) {
     if (mouse.subwindow == 0) return;
 
<a href="#h0-2" id="h0-2" class="h">@@ -193,18 +114,6 @@ void notify_motion(XEvent *e) {
</a>         wh + (mouse.button == 3 ? yd : 0));
 }
 
<a href="#h0-2-3" id="h0-2-3" class="d">-/*
</a><a href="#h0-2-4" id="h0-2-4" class="d">-   This function fires on a key press and checks to see if there
</a><a href="#h0-2-5" id="h0-2-5" class="d">-   is a matching and defined key binding. If there is a match the
</a><a href="#h0-2-6" id="h0-2-6" class="d">-   function bound to the key is executed.
</a><a href="#h0-2-7" id="h0-2-7" class="d">-
</a><a href="#h0-2-8" id="h0-2-8" class="d">-   The deprecated &#39;XKeycodeToKeysym&#39; is used as the replacement
</a><a href="#h0-2-9" id="h0-2-9" class="d">-   requires an additional include and I want to keep them to a
</a><a href="#h0-2-10" id="h0-2-10" class="d">-   minimum.
</a><a href="#h0-2-11" id="h0-2-11" class="d">-
</a><a href="#h0-2-12" id="h0-2-12" class="d">-   I highly doubt this deprecated function goes away any time soon
</a><a href="#h0-2-13" id="h0-2-13" class="d">-   and worst case, I simply update this code. Win-win.
</a><a href="#h0-2-14" id="h0-2-14" class="d">-*/
</a> void key_press(XEvent *e) {
     KeySym keysym = XKeycodeToKeysym(d, e-&gt;xkey.keycode, 0);
 
<a href="#h0-3" id="h0-3" class="h">@@ -213,15 +122,6 @@ void key_press(XEvent *e) {
</a>             keys[i].function(keys[i].arg);
 }
 
<a href="#h0-3-3" id="h0-3-3" class="d">-/*
</a><a href="#h0-3-4" id="h0-3-4" class="d">-   On a mouse button press the window below the cursor&#39;s
</a><a href="#h0-3-5" id="h0-3-5" class="d">-   attributes are stored, the window is raised and the &#39;mouse&#39;
</a><a href="#h0-3-6" id="h0-3-6" class="d">-   global is set.
</a><a href="#h0-3-7" id="h0-3-7" class="d">-
</a><a href="#h0-3-8" id="h0-3-8" class="d">-   Setting the &#39;mouse&#39; global tells the motion handling function
</a><a href="#h0-3-9" id="h0-3-9" class="d">-   that it should operate on the window as the user desires a move
</a><a href="#h0-3-10" id="h0-3-10" class="d">-   or resize.
</a><a href="#h0-3-11" id="h0-3-11" class="d">-*/
</a> void button_press(XEvent *e) {
     if (e-&gt;xbutton.subwindow == 0) return;
 
<a href="#h0-4" id="h0-4" class="h">@@ -230,26 +130,12 @@ void button_press(XEvent *e) {
</a>     mouse = e-&gt;xbutton;
 }
 
<a href="#h0-4-3" id="h0-4-3" class="d">-/*
</a><a href="#h0-4-4" id="h0-4-4" class="d">-   On a mouse button release we simply unset the &#39;mouse&#39; global
</a><a href="#h0-4-5" id="h0-4-5" class="d">-   as all of this mouse pointer nonsense is done.
</a><a href="#h0-4-6" id="h0-4-6" class="d">-
</a><a href="#h0-4-7" id="h0-4-7" class="d">-   We also reset the current window&#39;s fullscreen state as it is
</a><a href="#h0-4-8" id="h0-4-8" class="d">-   no longer at 0,0+[screen_width]X[screen_height].
</a><a href="#h0-4-9" id="h0-4-9" class="d">-*/
</a> void button_release() {
     for win if (c-&gt;w == mouse.subwindow) c-&gt;f = 0;
 
     mouse.subwindow = 0;
 }
 
<a href="#h0-4-16" id="h0-4-16" class="d">-/*
</a><a href="#h0-4-17" id="h0-4-17" class="d">-   This function is called whenever a window is mapped to the
</a><a href="#h0-4-18" id="h0-4-18" class="d">-   screen or moved to another desktop.
</a><a href="#h0-4-19" id="h0-4-19" class="d">-
</a><a href="#h0-4-20" id="h0-4-20" class="d">-   Memory is allocated for the new window and the current
</a><a href="#h0-4-21" id="h0-4-21" class="d">-   desktop&#39;s window list is updated.
</a><a href="#h0-4-22" id="h0-4-22" class="d">-*/
</a> void win_add(Window w) {
     client *c, *t;
 
<a href="#h0-5" id="h0-5" class="h">@@ -273,13 +159,6 @@ void win_add(Window w) {
</a>     ws_save(ws);
 }
 
<a href="#h0-5-3" id="h0-5-3" class="d">-/*
</a><a href="#h0-5-4" id="h0-5-4" class="d">-   This function is called whenever a window is destoyed
</a><a href="#h0-5-5" id="h0-5-5" class="d">-   or moved to another desktop.
</a><a href="#h0-5-6" id="h0-5-6" class="d">-
</a><a href="#h0-5-7" id="h0-5-7" class="d">-   Memory is freed and the current desktop&#39;s window list
</a><a href="#h0-5-8" id="h0-5-8" class="d">-   is updated.
</a><a href="#h0-5-9" id="h0-5-9" class="d">-*/
</a> void win_del(Window w) {
     for win if (c-&gt;w == w) {
         if (!c-&gt;prev &amp;&amp; !c-&gt;next) {
<a href="#h0-6" id="h0-6" class="h">@@ -307,29 +186,10 @@ void win_del(Window w) {
</a>     }
 }
 
<a href="#h0-6-3" id="h0-6-3" class="d">-/*
</a><a href="#h0-6-4" id="h0-6-4" class="d">-   This function is called from a key binding to
</a><a href="#h0-6-5" id="h0-6-5" class="d">-   close the currently focused window.
</a><a href="#h0-6-6" id="h0-6-6" class="d">-
</a><a href="#h0-6-7" id="h0-6-7" class="d">-   This differs from other window managers as we skip
</a><a href="#h0-6-8" id="h0-6-8" class="d">-   the questions and go straight to the killing of
</a><a href="#h0-6-9" id="h0-6-9" class="d">-   the window.
</a><a href="#h0-6-10" id="h0-6-10" class="d">-
</a><a href="#h0-6-11" id="h0-6-11" class="d">-   When I want to close a window I&#39;m not asking, I
</a><a href="#h0-6-12" id="h0-6-12" class="d">-   want the window closed and so it should immediately
</a><a href="#h0-6-13" id="h0-6-13" class="d">-   close.
</a><a href="#h0-6-14" id="h0-6-14" class="d">-
</a><a href="#h0-6-15" id="h0-6-15" class="d">-   &quot;Shoot first and don&#39;t ask questions later?..&quot;
</a><a href="#h0-6-16" id="h0-6-16" class="d">-*/
</a> void win_kill() {
     if (win_current() != root) XKillClient(d, cur);
 }
 
<a href="#h0-6-21" id="h0-6-21" class="d">-/*
</a><a href="#h0-6-22" id="h0-6-22" class="d">-   This function simply centers the window passed as
</a><a href="#h0-6-23" id="h0-6-23" class="d">-   an argument. If the argument is &#39;0&#39;, use the
</a><a href="#h0-6-24" id="h0-6-24" class="d">-   currently focused window.
</a><a href="#h0-6-25" id="h0-6-25" class="d">-*/
</a> void win_center(const Arg arg) {
     Window w = arg.w ? arg.w : win_current();
 
<a href="#h0-7" id="h0-7" class="h">@@ -338,18 +198,6 @@ void win_center(const Arg arg) {
</a>     XMoveWindow(d, w, (sw - ww) / 2, (sh - wh) / 2);
 }
 
<a href="#h0-7-3" id="h0-7-3" class="d">-/*
</a><a href="#h0-7-4" id="h0-7-4" class="d">-   This function toggles the fullscreen state for the
</a><a href="#h0-7-5" id="h0-7-5" class="d">-   window passed as an argument.
</a><a href="#h0-7-6" id="h0-7-6" class="d">-
</a><a href="#h0-7-7" id="h0-7-7" class="d">-   The window&#39;s data stucture holds an integer which
</a><a href="#h0-7-8" id="h0-7-8" class="d">-   is set to &#39;0&#39; for False and &#39;1&#39; for True.
</a><a href="#h0-7-9" id="h0-7-9" class="d">-
</a><a href="#h0-7-10" id="h0-7-10" class="d">-   When a window is set to fullscreen it is simply
</a><a href="#h0-7-11" id="h0-7-11" class="d">-   resized to fit the screen and the prior size and
</a><a href="#h0-7-12" id="h0-7-12" class="d">-   positioning is stored so it can be restored when
</a><a href="#h0-7-13" id="h0-7-13" class="d">-   the window is un-fullscreened.
</a><a href="#h0-7-14" id="h0-7-14" class="d">-*/
</a> void win_fs() {
     win_current();
 
<a href="#h0-8" id="h0-8" class="h">@@ -363,18 +211,6 @@ void win_fs() {
</a>     }
 }
 
<a href="#h0-8-3" id="h0-8-3" class="d">-/*
</a><a href="#h0-8-4" id="h0-8-4" class="d">-   This function simply moves the focused window to
</a><a href="#h0-8-5" id="h0-8-5" class="d">-   the desired desktop.
</a><a href="#h0-8-6" id="h0-8-6" class="d">-
</a><a href="#h0-8-7" id="h0-8-7" class="d">-   It firstly adds the window to the destination
</a><a href="#h0-8-8" id="h0-8-8" class="d">-   desktop&#39;s window list and secondly deletes it
</a><a href="#h0-8-9" id="h0-8-9" class="d">-   from the current desktop&#39;s window list.
</a><a href="#h0-8-10" id="h0-8-10" class="d">-
</a><a href="#h0-8-11" id="h0-8-11" class="d">-   The window is then unmapped from the screen and
</a><a href="#h0-8-12" id="h0-8-12" class="d">-   the focus is shifted to the first window in the
</a><a href="#h0-8-13" id="h0-8-13" class="d">-   list.
</a><a href="#h0-8-14" id="h0-8-14" class="d">-*/
</a> void win_to_ws(const Arg arg) {
     int tmp = ws;
     win_current();
<a href="#h0-9" id="h0-9" class="h">@@ -393,16 +229,6 @@ void win_to_ws(const Arg arg) {
</a>     if (list) win_focus(list-&gt;w);
 }
 
<a href="#h0-9-3" id="h0-9-3" class="d">-/*
</a><a href="#h0-9-4" id="h0-9-4" class="d">-   This function focuses the next window in the
</a><a href="#h0-9-5" id="h0-9-5" class="d">-   current desktop&#39;s window list.
</a><a href="#h0-9-6" id="h0-9-6" class="d">-
</a><a href="#h0-9-7" id="h0-9-7" class="d">-   If the end of the window list is reached it
</a><a href="#h0-9-8" id="h0-9-8" class="d">-   wraps back around to the start of the list.
</a><a href="#h0-9-9" id="h0-9-9" class="d">-
</a><a href="#h0-9-10" id="h0-9-10" class="d">-   The newly focused window is then raised to
</a><a href="#h0-9-11" id="h0-9-11" class="d">-   the top of the stack.
</a><a href="#h0-9-12" id="h0-9-12" class="d">-*/
</a> void win_next() {
     win_current();
 
<a href="#h0-10" id="h0-10" class="h">@@ -415,16 +241,6 @@ void win_next() {
</a>     }
 }
 
<a href="#h0-10-3" id="h0-10-3" class="d">-/*
</a><a href="#h0-10-4" id="h0-10-4" class="d">-    This function changes the focus to another desktop.
</a><a href="#h0-10-5" id="h0-10-5" class="d">-
</a><a href="#h0-10-6" id="h0-10-6" class="d">-    To make this operation invisible the destination
</a><a href="#h0-10-7" id="h0-10-7" class="d">-    desktop&#39;s windows are mapped first and the previous
</a><a href="#h0-10-8" id="h0-10-8" class="d">-    desktop&#39;s windows are then unmapped afterwards.
</a><a href="#h0-10-9" id="h0-10-9" class="d">-
</a><a href="#h0-10-10" id="h0-10-10" class="d">-    Finally, focus is shifted to the first window on the
</a><a href="#h0-10-11" id="h0-10-11" class="d">-    destination desktop&#39;s window list.
</a><a href="#h0-10-12" id="h0-10-12" class="d">-*/
</a> void ws_go(const Arg arg) {
     int tmp = ws;
 
<a href="#h0-11" id="h0-11" class="h">@@ -444,30 +260,15 @@ void ws_go(const Arg arg) {
</a>     if (list) win_focus(list-&gt;w);
 }
 
<a href="#h0-11-3" id="h0-11-3" class="d">-/*
</a><a href="#h0-11-4" id="h0-11-4" class="d">-    This function saves the current desktop&#39;s window list.
</a><a href="#h0-11-5" id="h0-11-5" class="d">-    Simple, nothing to see here.
</a><a href="#h0-11-6" id="h0-11-6" class="d">-*/
</a> void ws_save(int i) {
     ws_list[i].list = list;
 }
 
<a href="#h0-11-11" id="h0-11-11" class="d">-/*
</a><a href="#h0-11-12" id="h0-11-12" class="d">-    This function restores a saved desktop&#39;s window list.
</a><a href="#h0-11-13" id="h0-11-13" class="d">-    Simple, nothing to see here.
</a><a href="#h0-11-14" id="h0-11-14" class="d">-*/
</a> void ws_sel(int i) {
     list = ws_list[i].list;
     ws   = i;
 }
 
<a href="#h0-11-20" id="h0-11-20" class="d">-/*
</a><a href="#h0-11-21" id="h0-11-21" class="d">-   This function allows a window to request a size,
</a><a href="#h0-11-22" id="h0-11-22" class="d">-   position and other attributes.
</a><a href="#h0-11-23" id="h0-11-23" class="d">-
</a><a href="#h0-11-24" id="h0-11-24" class="d">-   This is required so programs like Firefox or MPV
</a><a href="#h0-11-25" id="h0-11-25" class="d">-   are able to display and function correctly.
</a><a href="#h0-11-26" id="h0-11-26" class="d">-*/
</a> void configure_request(XEvent *e) {
     XConfigureRequestEvent *ev = &amp;e-&gt;xconfigurerequest;
 
<a href="#h0-12" id="h0-12" class="h">@@ -481,17 +282,6 @@ void configure_request(XEvent *e) {
</a>     });
 }
 
<a href="#h0-12-3" id="h0-12-3" class="d">-/*
</a><a href="#h0-12-4" id="h0-12-4" class="d">-   This function is executed whenever a window is mapped to
</a><a href="#h0-12-5" id="h0-12-5" class="d">-   the screen.
</a><a href="#h0-12-6" id="h0-12-6" class="d">-
</a><a href="#h0-12-7" id="h0-12-7" class="d">-   The window is centered, mapped to the screen, focused and
</a><a href="#h0-12-8" id="h0-12-8" class="d">-   finally added to the current desktop&#39;s window list.
</a><a href="#h0-12-9" id="h0-12-9" class="d">-
</a><a href="#h0-12-10" id="h0-12-10" class="d">-   &#39;XSelectInput&#39; is called to subscribe to various events
</a><a href="#h0-12-11" id="h0-12-11" class="d">-   related to the window. For example, this is used to get
</a><a href="#h0-12-12" id="h0-12-12" class="d">-   focus-follows-cursor to work.
</a><a href="#h0-12-13" id="h0-12-13" class="d">-*/
</a> void map_request(XEvent *e) {
     Window w = e-&gt;xmaprequest.window;
 
<a href="#h0-13" id="h0-13" class="h">@@ -505,10 +295,6 @@ void map_request(XEvent *e) {
</a>     win_add(w);
 }
 
<a href="#h0-13-3" id="h0-13-3" class="d">-/*
</a><a href="#h0-13-4" id="h0-13-4" class="d">-    This function is executed by keybindings to run the
</a><a href="#h0-13-5" id="h0-13-5" class="d">-    specified program. Simple enough.
</a><a href="#h0-13-6" id="h0-13-6" class="d">-*/
</a> void run(const Arg arg) {
     if (fork()) return;
     if (d) close(ConnectionNumber(d));
<a href="#h0-14" id="h0-14" class="h">@@ -517,17 +303,6 @@ void run(const Arg arg) {
</a>     execvp((char*)arg.com[0], (char**)arg.com);
 }
 
<a href="#h0-14-3" id="h0-14-3" class="d">-/*
</a><a href="#h0-14-4" id="h0-14-4" class="d">-    Initialize the window manager by registering all
</a><a href="#h0-14-5" id="h0-14-5" class="d">-    keybindings, setting some globals and starting the
</a><a href="#h0-14-6" id="h0-14-6" class="d">-    event loop.
</a><a href="#h0-14-7" id="h0-14-7" class="d">-
</a><a href="#h0-14-8" id="h0-14-8" class="d">-    There&#39;s no &#39;XCloseDisplay&#39; or clean up as the only
</a><a href="#h0-14-9" id="h0-14-9" class="d">-    way to exit this window manager is to kill the process.
</a><a href="#h0-14-10" id="h0-14-10" class="d">-
</a><a href="#h0-14-11" id="h0-14-11" class="d">-    This fires up Xorg&#39;s internal clean up which covers
</a><a href="#h0-14-12" id="h0-14-12" class="d">-    everything allocated and executed here. It&#39;s free!
</a><a href="#h0-14-13" id="h0-14-13" class="d">-*/
</a> int main(void) {
     XEvent ev;
 
</pre>
</div>
</body>
</html>
